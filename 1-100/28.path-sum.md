# 路径总和

## 自己写的代码
```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) {
            return false;
        } else if(root.right == null && root.left == null && sum == root.val) {
            return true;
        } else {
            return hasPathSum(root.right,sum-root.val) || hasPathSum(root.left,sum-root.val);
        }
    }
}
```

#### 这波代码是最近几天写的最舒服的一遍了,想过好几种思路,这种应该是最简单的.
还是这个递归的方法,从根节点开始每次都减去当前的val值,如果到了叶子节点,剩下的sum == val的话就说明走的这条递归道路正好是要找的那条.要注意的是在如何判断是否是叶子节点这一块,要是单独拿出来问你什么是叶子节点,那肯定能给出判断没有下一个节点的节点就是叶子节点.但是在考虑算法的过程中,经常性会想当然的以为root递归到null才算是结束.这种想法是不对的.

## 根据这几天的经验,总结了一下写递归函数的方法:

##### 1.首先是什么样的场合应该用到递归这个问题,其实像树/链/图这种相互之间有一定关系联系的,而且这个关系是确1定的.还有一些比如计算n!这种,其实也算是有联系吧,每个相乘的元素之间都相差1嘛.这个关系也是确定的可以得到的.这种就可以用递归的方法来遍历和操作.

##### 2.然后是一个终点的问题,这也是个比较关键的问题,不然总不可能永远递归下去.设好一个条件,当递归到这个元素满足条件的时候,就不在进行递归,往往是返回一个实体.

##### 3.最后是递归主题.递归主题不但要写好写入递归元素之间的联系,使得每个递归都能准确的找到下一个元素,还要写入主题的操作,就是你这个递归是用来干什么的,要完成什么目的,这个其实简单一点其实就随便那个数量小一点的例子自己推算一遍,一般来说都是可以实现的.
