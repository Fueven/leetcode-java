# 31.下一个排列
### 题目 ：
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。  
1,2,3 → 1,3,2  
3,2,1 → 1,2,3  
1,1,5 → 1,5,1  

###代码：
####思想：
（1）从后向前遍历，找到第一个不满足降序的元素；若初始序列全部是降序，则i为-1，直接跳转至（3）；  
（2）将该元素同它后面的元素中比它大的第一个元素交换；  
（3）将该元素后的所有元素排列，使之成为最小的排列。  
```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        if(nums == null || n == 0 || n == 1) {
            return;
        }
        //从后向前找到第一个不满足逆序的元素
        int i = n - 2;
        for(; i >= 0 && nums[i] >= nums[i + 1]; --i); //注意，这里有=，可以排除含有重复元素的情况
        //从i+1位置开始，向后查找比nums[i]大的最小元素
        if(i >= 0){
            int j = i + 1;
            for(; j < nums.length && nums[j] > nums[i]; ++j);
            swap(nums,i,j - 1); //交换，注意是同 j - 1交换
        }
        //将i之后的元素逆置(这里包含一种特殊情况，若该排列已经是字典序中的最大了，则下一个序列应该是最小字典序，因此，直接在这里逆置即可)
        int k = nums.length - 1;
        i++;
        for(; i < k; i++, k--) {
            swap(nums, i, k);           
        }

    }
    /**
     * 交换元素
     */
    public void swap(int[] array,int i ,int j){
        //交换
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
```
